#!/usr/bin/python

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 
# $$$$$$$$\ $$$$$$$\  $$$$$$$\  
# \____$$  |$$  __$$\ $$  __$$\ 
#     $$  / $$ |  $$ |$$ |  $$ |
#    $$  /  $$ |  $$ |$$$$$$$\ |
#   $$  /   $$ |  $$ |$$  __$$\ 
#  $$  /    $$ |  $$ |$$ |  $$ |
# $$$$$$$$\ $$$$$$$  |$$$$$$$  |
# \________|\_______/ \_______/ 
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# USAGE:
# some python functions to set and retrieve scores from a ZDB file
# 
# by @jonbrennecke / github.com/jonbrennecke
# 
# 
from zdbutils import *
import numpy as np
import csv, sqlite3, contextlib, sys, argparse, os, errno


class ZDB(object):

	"""

	Neuroscore database object

	"""

	def __init__(self, zdbfile):
		self.file = zdbfile

		# the following SQL generates an empty ZDB database from scratch
		# (this was generated by "select sql from sqlite_master" from an arbitrary ZDB file)
		self.sqlite_master = """
			CREATE TABLE internal_property (id INTEGER PRIMARY KEY, name TEXT, key TEXT, type TEXT, value TEXT);
			CREATE TABLE logging_log_entry (id INTEGER PRIMARY KEY, time INTEGER(8), user TEXT, level INTEGER(8), message TEXT, category TEXT, data TEXT);
			CREATE TABLE scoring_key (id INTEGER PRIMARY KEY, date_created INTEGER(8), name TEXT, owner TEXT, type TEXT);
			CREATE TABLE workspace_workspace (id INTEGER PRIMARY KEY, data BLOB);
			CREATE TABLE temporary_scoring_key (id INTEGER PRIMARY KEY, date_created INTEGER(8), name TEXT, owner TEXT, type TEXT);
			CREATE TABLE temporary_scoring_marker (id INTEGER PRIMARY KEY, starts_at INTEGER(8), ends_at INTEGER(8), notes TEXT, type TEXT, location TEXT, is_deleted INTEGER(1), key_id INTEGER);
			CREATE TABLE temporary_scoring_group (id INTEGER PRIMARY KEY, name TEXT, is_deleted INTEGER(1), tags TEXT);
			CREATE TABLE temporary_scoring_group_to_key (group_id INTEGER(8), key_id INTEGER(8));
			CREATE TABLE temporary_scoring_group_to_comment (group_id INTEGER(8), comment_id INTEGER(8));
			CREATE TABLE temporary_scoring_comment (id INTEGER PRIMARY KEY, category TEXT, key TEXT, value TEXT);"""

		self.open()

	def __enter__(self):
		return self

	def __exit__(self,type,value,traceback):
		self.close()

	@contextlib.contextmanager
	def open_w_error(self) :
		if not os.path.isfile(self.file) :
			yield None, IOError(errno.ENOENT,os.strerror(errno.ENOENT))

		try:
			db = sqlite3.connect(self.file)
		except IOError, err:
			yield None, err
		else:
			yield db, None

	# open the database
	def open(self):
		with self.open_w_error() as (db,err) :
			if err :
				if err.errno is errno.ENOENT :
					# the file doesn't exist, so make a new ZDB from scratch
					self.db = sqlite3.connect(self.file)

					c = self.db.cursor()
					c.executescript(self.sqlite_master);
					self.db.commit()

				else:
					raise err
			else :
				self.db = db

	# scores property retrieves all the scores from the file 
	@property
	def scores(self):
		if self.db :
			c = self.db.cursor()
			c.execute("SELECT type FROM temporary_scoring_marker;")
			return [ convertNameToChar(score) for score in c.fetchall() ]
		else :
			self.open()
			return self.scores

	# convert the ZDB scoring keys to single character values
	@scores.setter
	def scores(self,info) :
		timestamps, newscores = info;
		c = self.db.cursor()
		for i, char in enumerate(newscores) :
			score = convertCharToName(char)
			ticks = convertScoretimeToTicks(timestamps[i])
			c.execute('UPDATE temporary_scoring_marker SET type=\"'+score+'\" WHERE starts_at='+str(ticks)+';')
			if c.rowcount == 0 :
				print Warning("'UPDATE' failed to set score at timestamp: "+str(convertTicksToScoretime(ticks)))

	# save and close the zdb
	def close(self) :
		self.db.commit()
		self.db.close()
		

class TXT(object):
	
	"""

	TXT file object

	"""
	def __init__(self, txtfile):
		self.file = txtfile
		with open(txtfile) as f :
			self.data = np.array([ cell for cell in csv.reader(f,delimiter='\t') ])

	def __enter__(self):
		return self

	def __exit__(self,type,value,traceback):
		pass

	# get the timestamp and score field from a text file
	@property
	def scores(self) :
		return self.data[2:,1]

	@property
	def timestamps(self) :
		return self.data[2:,0]



if __name__ == '__main__':

	# parse arguments
	parser = argparse.ArgumentParser(description='Read and write data to a ZDB file.')
	parser.add_argument('-zdb', dest='zdbfile', type=str, help='the ZDB database file')
	parser.add_argument('-txt', dest='txtfile', type=str, help='the TXT file')
	args = parser.parse_args(sys.argv[1:])

	with TXT(args.txtfile) as txt :
		with ZDB(args.zdbfile) as zdb :
			zdb.scores = ( txt.timestamps, txt.scores )
